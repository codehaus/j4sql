/*
 * Created on Jan 23, 2005
 */

package org.j4sql.doclet;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.text.DateFormat;
import java.util.Date;
import java.util.Iterator;

import org.apache.tools.ant.BuildException;
import org.j4sql.common.Callable;
import org.j4sql.common.DbPlatform;
import org.j4sql.common.Entity;
import org.j4sql.common.Function;
import org.j4sql.common.NotSupportedException;
import org.j4sql.common.Parameter;
import org.j4sql.common.Trigger;

import com.thoughtworks.qdox.ant.AbstractQdoxTask;
import com.thoughtworks.qdox.model.DocletTag;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaMethod;
import com.thoughtworks.qdox.model.JavaParameter;

/**
 * 
 * 
 * @author Laszlo Hornyak
 */
public class QDoxJ4SQLGenerator extends AbstractQdoxTask {

	private DbPlatform m_dbPlatform = null;

	private String m_dbPlatformClass = null;

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.thoughtworks.qdox.ant.AbstractQdoxTask#execute()
	 */
	public void execute() throws BuildException {

		try {
			if (targetPath == null) {
				throw new BuildException(
						"The attribute targetPath is mandatory");
			}
			if (m_dbPlatformClass == null) {
				throw new BuildException(
						"The attribute dbPlatformClass is mandatory");
			}
			super.execute();

			// dbPlatform = new PostgreSQLPLJ();
			m_dbPlatform = (DbPlatform) Class.forName(m_dbPlatformClass)
					.newInstance();
			log("Generating code for " + m_dbPlatform.getName());

			FileOutputStream fos = null;
			try {
				fos = new FileOutputStream(targetPath + File.separator
						+ m_dbPlatform.getName() + ".sql");
			} catch (FileNotFoundException e) {
				throw new BuildException("File not found", e);
			}
			PrintWriter pw = new PrintWriter(fos);
			DateFormat df = DateFormat.getInstance();

			m_dbPlatform.writeComment("Generated by J4SQL doclet task version 0.1 dev", pw);
			m_dbPlatform.writeComment("see: http://j4sql.codehaus.org/", pw);
			m_dbPlatform.writeComment(df.format(new Date()), pw);
			pw.write("\n\n");
			m_dbPlatform.writeComment("Deployment file for "
					+ m_dbPlatform.getName(), pw);

			Iterator i = allClasses.iterator();
			while (i.hasNext()) {

				JavaClass jcl = (JavaClass) i.next();
				log(jcl.getName());
				JavaMethod[] methods = jcl.getMethods();
				for (int j = 0; j < methods.length; j++) {
					processMethod(methods[j], jcl, pw);
				}
			}
			pw.flush();
			pw.close();
		} catch (Exception e) {
			e.printStackTrace();
			throw new BuildException(e);
		}

	}

	private String targetPath = null;

	public String getTargetPath() {
		return targetPath;
	}

	public void setTargetPath(String targetPath) {
		this.targetPath = targetPath;
	}

	private Parameter makeParameter(JavaParameter paramDesc, DocletTag tag) {
		Parameter p = new Parameter();
		if (tag != null) {
			String desc[] = tag.getParameters();
			int mode = 0;
			if ("in".equals(desc[1])) {
				mode = Parameter.PARAM_TYPE_IN;
			} else if ("out".equals(desc[1])) {
				mode = Parameter.PARAM_TYPE_OUT;
			} else {
				mode = Parameter.PARAM_TYPE_INOUT;
			}
			p.setParamType(mode);
			p.setSqlType(desc[2]);
		} else {
			p.setParamType(Parameter.PARAM_TYPE_IN);
		}
		p.setJavaType(paramDesc.getType().getJavaClass()
				.getFullyQualifiedName());
		p.setName(paramDesc.getName());
		p.setSqlType("");
		return p;
	}

	private static final String J4SQL_FUNCTION = "j4sql.function";

	private static final String J4SQL_TRIGGER = "j4sql.trigger";

	private void processMethod(JavaMethod method, JavaClass clazz,
			PrintWriter pw) throws BuildException, NotSupportedException {
		if (method.getTagsByName(J4SQL_FUNCTION).length > 1)
			throw new BuildException(
					"More UDF declared on the same method, this is not supperted. Method:"
							+ method.getName() + " Class:"
							+ clazz.getFullyQualifiedName());
		DocletTag fnDoc = method.getTagByName("j4sql.function");
		DocletTag procDoc = method.getTagByName("j4sql.procedure");
		DocletTag[] trigDocs = method.getTagsByName(J4SQL_TRIGGER);
		Entity entity = null;
		if (fnDoc != null) {
			entity = processFunction(fnDoc, method, clazz, pw);
			m_dbPlatform.writeEntity(entity, pw);
		} else if (procDoc != null) {
			// entity = pro
		}
		if (trigDocs != null && trigDocs.length > 0) {
			// entity = pro
		}
	}

	private Function processFunction(DocletTag fnDoc, JavaMethod method,
			JavaClass clazz, PrintWriter pw) throws BuildException,
			NotSupportedException {
		Function fn = new Function();

		if ((!method.isStatic()) || (!method.isPublic()))
			throw new NotSupportedException(
					"Java stored procedures must be public static methods. Class: "
							+ clazz.getName() + " Method:" + method.getName());

		if (!clazz.isPublic())
			throw new NotSupportedException(
					"Java stored procedures must be public in public classes. Class: "
							+ clazz.getName());

		String fnName = fnDoc.getNamedParameter("name");
		if (fnName == null)
			throw new BuildException();
		fn.setName(fnName);
		fn.setJavaClassName(clazz.getFullyQualifiedName());
		fn.setJavaMethodName(method.getName());

		String onNull = fnDoc.getNamedParameter("onNullInput");
		if (onNull == null) {
			fn.setCalledOnNullInput(true);
		} else {
			fn.setCalledOnNullInput("called".equalsIgnoreCase(onNull));
		}

		String fnDet = fnDoc.getNamedParameter("deterministic");
		if (fnDet == null) {
			fn.setDeterministic(false);
		} else {
			fn.setDeterministic("true".equalsIgnoreCase(fnDet));
		}

		String fnSql = fnDoc.getNamedParameter("sqlAccess");
		if (fnSql == null) {
			fn.setSqlAccess(Callable.SQLACCESS_CONTAINS);
		} else {
			if ("none".equalsIgnoreCase(fnSql))
				fn.setSqlAccess(Callable.SQLACCESS_NO);
			else if ("contains".equalsIgnoreCase(fnSql))
				fn.setSqlAccess(Callable.SQLACCESS_CONTAINS);
			else if ("modifies".equalsIgnoreCase(fnSql))
				fn.setSqlAccess(Callable.SQLACCESS_MODIFIES);
			else if ("reads".equalsIgnoreCase(fnSql))
				fn.setSqlAccess(Callable.SQLACCESS_READS);
			else
				throw new BuildException(
						"Value not supported for @j4sql.function sqlAccess parameter: "
								+ fnSql + " in method:" + method.getName()
								+ " class:" + clazz.getFullyQualifiedName());
		}

		StringBuffer comments = new StringBuffer(method.getComment());
		comments.append("\n\n");
		JavaParameter[] params = method.getParameters();
		if (params.length > 0) {
			comments.append("\nParameters:\n============\n");
		}
		DocletTag[] paramDocs = method.getTagsByName("param");
		for (int i = 0; i < params.length; i++) {
			Parameter param = processParamerter(comments, method, params[i],
					paramDocs);
			fn.getParameters().add(param);
		}

		/* TODO: add returns to SQL comment */
		DocletTag javaReturn = method.getTagByName("return");
		if (javaReturn != null) {
			String fnRet = javaReturn.getValue();
			comments.append("\nReturns:\n============\n").append(fnRet).append(
					"\n");
		}

		DocletTag j4SQLReturn = method.getTagByName("j4sql.returns");
		if (j4SQLReturn != null) {
			fn.setSqlReturnType(j4SQLReturn.getValue());
		}
		fn.setJavaReturnType(method.getReturns().getJavaClass()
				.getFullyQualifiedName());

		fn.setComment(comments.toString());
		return fn;
	}

	private Trigger processTrigger(JavaMethod method, JavaClass clazz,
			PrintWriter pw) {
		return null;
	}

	private Trigger processTrigger(Callable callable, PrintWriter pw) {
		return null;
	}

	private Parameter processParamerter(StringBuffer commentBuf, JavaMethod m,
			JavaParameter param, DocletTag[] params) throws BuildException {

		// TODO: SQL comment on should contain the parameter documentation
		// (J4SQL-3)
		commentBuf.append(param.getName()).append("\t\t").append("\n");

		Parameter p = new Parameter();
		p.setJavaType(param.getType().toString());
		p.setName(param.getName());
		for (int i = 0; i < params.length; i++) {
			String name = params[i].getNamedParameter("name");
			if (p.getName().equals(name)) {

				String type = params[i].getNamedParameter("type");
				p.setSqlType(type);

				String mode = params[i].getNamedParameter("mode");
				if ("in".equals(mode))
					p.setParamType(Parameter.PARAM_TYPE_IN);
				else if ("out".equals(mode))
					p.setParamType(Parameter.PARAM_TYPE_OUT);
				else if ("inout".equals(mode))
					p.setParamType(Parameter.PARAM_TYPE_INOUT);
				else if (mode != null)
					throw new BuildException(
							"'mode' should be in, out or inout in method"
									+ m.getDeclarationSignature(true));

				break;
			}
		}
		return p;
	}

	public String getDbPlatformClass() {
		return m_dbPlatformClass;
	}

	public void setDbPlatformClass(String platformClass) {
		m_dbPlatformClass = platformClass;
	}
}